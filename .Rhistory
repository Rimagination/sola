# 将结果放入相应的位置
radiation_values[(i - 1) * ncell(ssd) + 1:i * ncell(ssd)][valid_indices] <- radiation_results
}
}))
# 向量化计算太阳辐射，并显示进度条
for (i in pblapply(1:nlyr(ssd), function(i) {
# 当前层的SSD值
current_ssd <- ssd_values[(i - 1) * ncell(ssd) + 1:i * ncell(ssd)]
# 获取有效（非NA且在范围内）值的索引
valid_indices <- !is.na(current_ssd) & current_ssd >= 0 & current_ssd <= 24
# 处理无效的SSD值，将对应结果设为NA
radiation_values[(i - 1) * ncell(ssd) + 1:i * ncell(ssd)][!valid_indices] <- NA
if (any(valid_indices)) {
# 计算有效的经纬度
lat_valid <- lats[valid_indices]
lon_valid <- lons[valid_indices]
ssd_valid <- current_ssd[valid_indices]
# 使用 sol_rad 函数计算太阳辐射
radiation_results <- sol_rad(lat = lat_valid, date = dates[i], ssd = ssd_valid, A = 0.25, B = 0.5)
# 将结果放入相应的位置
radiation_values[(i - 1) * ncell(ssd) + 1:i * ncell(ssd)][valid_indices] <- radiation_results
}
}))
# 向量化计算太阳辐射，并显示进度条
for (i in pblapply(1:nlyr(ssd), function(i) {
# 当前层的SSD值
current_ssd <- ssd_values[(i - 1) * ncell(ssd) + 1:i * ncell(ssd)]
# 获取有效（非NA且在范围内）值的索引
valid_indices <- !is.na(current_ssd) & current_ssd >= 0 & current_ssd <= 24
# 处理无效的SSD值，将对应结果设为NA
radiation_values[(i - 1) * ncell(ssd) + 1:i * ncell(ssd)][!valid_indices] <- NA
if (any(valid_indices)) {
# 计算有效的经纬度
lat_valid <- lats[valid_indices]
lon_valid <- lons[valid_indices]
ssd_valid <- current_ssd[valid_indices]
# 使用 sol_rad 函数计算太阳辐射
radiation_results <- sol_rad(lat = lat_valid, date = dates[i], ssd = ssd_valid, A = 0.25, B = 0.5)
# 将结果放入相应的位置
radiation_values[(i - 1) * ncell(ssd) + 1:i * ncell(ssd)][valid_indices] <- radiation_results
}
}))
# 向量化计算太阳辐射，并显示进度条
for (i in pblapply(1:nlyr(ssd), function(i) {
# 当前层的SSD值
current_ssd <- ssd_values[(i - 1) * ncell(ssd) + 1:i * ncell(ssd)]
# 获取有效（非NA且在范围内）值的索引
valid_indices <- !is.na(current_ssd) & current_ssd >= 0 & current_ssd <= 24
# 处理无效的SSD值，将对应结果设为NA
radiation_values[(i - 1) * ncell(ssd) + 1:i * ncell(ssd)][!valid_indices] <- NA
if (any(valid_indices)) {
# 计算有效的经纬度
lat_valid <- lats[valid_indices]
lon_valid <- lons[valid_indices]
ssd_valid <- current_ssd[valid_indices]
# 使用 sol_rad 函数计算太阳辐射
radiation_results <- sol_rad(lat = lat_valid, date = dates[i], ssd = ssd_valid, A = 0.25, B = 0.5)
# 将结果放入相应的位置
radiation_values[(i - 1) * ncell(ssd) + 1:i * ncell(ssd)][valid_indices] <- radiation_results
}
}))
# 向量化计算太阳辐射，并显示进度条
for (i in pblapply(1:nlyr(ssd), function(i) {
# 当前层的SSD值
current_ssd <- ssd_values[(i - 1) * ncell(ssd) + 1:i * ncell(ssd)]
# 获取有效（非NA且在范围内）值的索引
valid_indices <- !is.na(current_ssd) & current_ssd >= 0 & current_ssd <= 24
# 处理无效的SSD值，将对应结果设为NA
radiation_values[(i - 1) * ncell(ssd) + 1:i * ncell(ssd)][!valid_indices] <- NA
if (any(valid_indices)) {
# 计算有效的经纬度
lat_valid <- lats[valid_indices]
lon_valid <- lons[valid_indices]
ssd_valid <- current_ssd[valid_indices]
# 使用 sol_rad 函数计算太阳辐射
radiation_results <- sol_rad(lat = lat_valid, date = dates[i], ssd = ssd_valid, A = 0.25, B = 0.5)
# 将结果放入相应的位置
radiation_values[(i - 1) * ncell(ssd) + 1:i * ncell(ssd)][valid_indices] <- radiation_results
}
}))
# 创建有效值的掩码
valid_mask <- !is.na(ssd_values) & ssd_values >= 0 & ssd_values <= 24
library(terra)
library(sirad)
library(pbapply)
# 读取NetCDF文件
filename <- system.file("extdata", "ssd.nc", package = "sola")  # 加载示例数据
ssd <- rast(filename)
# 提取所有时间属性
dates <- time(ssd)
# 提取所有像元的经纬度
lons <- xFromCell(ssd, 1:ncell(ssd))
lats <- yFromCell(ssd, 1:ncell(ssd))
# 展平SSD数据
ssd_values <- as.vector(values(ssd))
# 创建有效值的掩码
valid_mask <- !is.na(ssd_values) & ssd_values >= 0 & ssd_values <= 24
# 使用sol_rad计算所有有效值的太阳辐射
radiation_results <- numeric(length(ssd_values))
# 计算有效值的索引
valid_indices <- which(valid_mask)
# 计算每个时间步的太阳辐射
radiation_results <- rep(NA, length(ssd_values))
# 向量化计算太阳辐射
if (length(valid_indices) > 0) {
# 提取有效的经纬度和SSD值
lat_valid <- lats[valid_indices]
lon_valid <- lons[valid_indices]
ssd_valid <- ssd_values[valid_indices]
# 使用 sol_rad 函数计算太阳辐射
radiation_values <- sol_rad(lat = lat_valid, date = rep(dates, each = ncell(ssd))[valid_indices], ssd = ssd_valid, A = 0.25, B = 0.5)
# 将结果放入相应的向量中
radiation_results[valid_indices] <- radiation_values
}
library(terra)
library(sirad)
library(pbapply)
# 读取NetCDF文件
filename <- system.file("extdata", "ssd.nc", package = "sola")  # 加载示例数据
ssd <- rast(filename)
# 提取所有时间属性
dates <- time(ssd)
# 提取所有像元的经纬度
lons <- xFromCell(ssd, 1:ncell(ssd))
lats <- yFromCell(ssd, 1:ncell(ssd))
# 初始化结果矩阵
radiation <- matrix(NA, nrow = nlyr(ssd), ncol = ncell(ssd))
# 向量化计算太阳辐射，并显示进度条
radiation_results <- pblapply(1:nlyr(ssd), function(i) {
ssd_values <- values(ssd[[i]])  # 提取当前层的SSD值
# 获取有效（非NA且在范围内）值的索引
valid_indices <- !is.na(ssd_values) & ssd_values >= 0 & ssd_values <= 24
# 处理无效的SSD值，将对应结果设为NA
radiation[i, is.na(ssd_values) | ssd_values < 0 | ssd_values > 24] <- NA
if (any(valid_indices)) {
# 使用 sol_rad 函数计算太阳辐射
radiation_values <- sol_rad(lat = lats[valid_indices], date = dates[i], ssd = ssd_values[valid_indices], A = 0.25, B = 0.5)
# 将结果放入相应的矩阵中
return(radiation_values)  # 返回计算结果
} else {
return(rep(NA, sum(!is.na(ssd_values))))  # 返回 NA 对应的结果
}
})
# 将结果转换为矩阵
radiation <- do.call(rbind, radiation_results)
View(radiation_results)
library(terra)
library(sirad)
library(pbapply)
# 读取NetCDF文件
filename <- system.file("extdata", "ssd.nc", package = "sola")  # 加载示例数据
ssd <- rast(filename)
# 提取所有时间属性
dates <- time(ssd)
# 提取所有像元的经纬度
lons <- xFromCell(ssd, 1:ncell(ssd))
lats <- yFromCell(ssd, 1:ncell(ssd))
# 初始化结果矩阵
radiation <- matrix(NA, nrow = nlyr(ssd), ncol = ncell(ssd))
# 向量化计算太阳辐射，并显示进度条
radiation_results <- pblapply(1:nlyr(ssd), function(i) {
ssd_values <- values(ssd[[i]])  # 提取当前层的SSD值
# 获取有效（非NA且在范围内）值的索引
valid_indices <- !is.na(ssd_values) & ssd_values >= 0 & ssd_values <= 24
# 初始化该层的辐射结果为NA
radiation_layer <- rep(NA, ncell(ssd))
# 处理有效的像元
if (any(valid_indices)) {
lat_valid <- lats[valid_indices]
ssd_valid <- ssd_values[valid_indices]
# 使用 sol_rad 函数计算太阳辐射
radiation_values <- sol_rad(lat = lat_valid, date = dates[i], ssd = ssd_valid, A = 0.25, B = 0.5)
# 将计算结果插入到对应的有效索引位置
radiation_layer[valid_indices] <- radiation_values
}
return(radiation_layer)  # 返回该层的结果（包括NA）
})
# 将结果转换为矩阵
radiation <- do.call(rbind, radiation_results)
# 将结果直接转换为SpatRaster对象，保持原有结构
radiation_raster <- ssd
values(radiation_raster) <- as.numeric(radiation)
# 保存结果为NetCDF文件
writeCDF(radiation_raster, "D:/CN05/roi/radiation_2020_2022.nc", overwrite = TRUE)
# 可视化结果
plot(radiation_raster)
ssd
plot(ssd)
library(terra)
library(sirad)
library(pbapply)
# 读取NetCDF文件
filename <- system.file("extdata", "ssd.nc", package = "sola")  # 加载示例数据
ssd <- rast(filename)
# 提取所有时间属性
dates <- time(ssd)
# 提取所有像元的经纬度
lons <- xFromCell(ssd, 1:ncell(ssd))
lats <- yFromCell(ssd, 1:ncell(ssd))
# 将所有图层展开为一个长向量
ssd_values <- values(ssd)
# 初始化结果矩阵，结果与输入的维度一致
radiation <- matrix(NA, nrow = nlyr(ssd), ncol = ncell(ssd))
# 提取所有经纬度、日期和 SSD 值并展开
lat_extended <- rep(lats, nlyr(ssd))
date_extended <- rep(dates, each = ncell(ssd))
# 使用 sol_rad 函数计算太阳辐射，对所有数据进行处理，包括 NA
radiation_values <- sol_rad(lat = lat_extended, date = date_extended, ssd = ssd_values, A = 0.25, B = 0.5)
# 将计算结果按原始顺序填充回结果矩阵
radiation <- matrix(radiation_values, nrow = nlyr(ssd), byrow = TRUE)
# 将结果直接转换为 SpatRaster 对象，保持原有结构
radiation_raster <- ssd
values(radiation_raster) <- as.numeric(radiation)
# 保存结果为 NetCDF 文件
writeCDF(radiation_raster, "D:/CN05/roi/radiation_2020_2022.nc", overwrite = TRUE)
# 可视化结果
plot(radiation_raster)
plot(ssd)
library(terra)
library(sirad)
library(pbapply)
# 读取NetCDF文件
filename <- system.file("extdata", "ssd.nc", package = "sola")  # 加载示例数据
ssd <- rast(filename)
# 提取所有时间属性
dates <- time(ssd)
# 提取所有像元的经纬度
lons <- xFromCell(ssd, 1:ncell(ssd))
lats <- yFromCell(ssd, 1:ncell(ssd))
# 将所有图层展开为一个长向量
ssd_values <- values(ssd)
# 初始化结果矩阵，结果与输入的维度一致
radiation <- matrix(NA, nrow = nlyr(ssd), ncol = ncell(ssd))
# 向量化计算太阳辐射
for (i in seq_len(nlyr(ssd))) {
ssd_layer_values <- ssd_values[(i - 1) * ncell(ssd) + 1:i * ncell(ssd)]  # 当前层的SSD值
valid_indices <- !is.na(ssd_layer_values) & ssd_layer_values >= 0 & ssd_layer_values <= 24  # 获取有效（非NA且在范围内）值的索引
# 计算有效的经纬度
lat_valid <- lats[valid_indices]
lon_valid <- lons[valid_indices]
ssd_valid <- ssd_layer_values[valid_indices]
# 使用 sol_rad 函数计算太阳辐射
radiation_values <- rep(NA, length(ssd_layer_values))  # 初始化结果向量
if (length(ssd_valid) > 0) {
radiation_values[valid_indices] <- sol_rad(lat = lat_valid, date = dates[i], ssd = ssd_valid, A = 0.25, B = 0.5)
}
# 将结果放入相应的矩阵中
radiation[i, ] <- radiation_values
}
library(terra)
library(sirad)
library(pbapply)
# 读取NetCDF文件
filename <- system.file("extdata", "ssd.nc", package = "sola")  # 加载示例数据
ssd <- rast(filename)
# 提取所有时间属性
dates <- time(ssd)
# 提取所有像元的经纬度
lons <- xFromCell(ssd, 1:ncell(ssd))
lats <- yFromCell(ssd, 1:ncell(ssd))
# 将所有图层展开为一个长向量
ssd_values <- values(ssd)
# 初始化结果矩阵，结果与输入的维度一致
radiation <- matrix(NA, nrow = nlyr(ssd), ncol = ncell(ssd))
# 向量化计算太阳辐射
for (i in seq_len(nlyr(ssd))) {
ssd_layer_values <- ssd_values[(i - 1) * ncell(ssd) + 1:i * ncell(ssd)]  # 当前层的SSD值
valid_indices <- !is.na(ssd_layer_values) & ssd_layer_values >= 0 & ssd_layer_values <= 24  # 获取有效（非NA且在范围内）值的索引
# 计算有效的经纬度
lat_valid <- lats[valid_indices]
lon_valid <- lons[valid_indices]
ssd_valid <- ssd_layer_values[valid_indices]
# 初始化 radiation_values，确保长度与 SSD 层一致
radiation_values <- rep(NA, length(ssd_layer_values))
# 使用 sol_rad 函数计算太阳辐射
if (length(ssd_valid) > 0) {
radiation_values[valid_indices] <- sol_rad(lat = lat_valid, date = dates[i], ssd = ssd_valid, A = 0.25, B = 0.5)
}
# 将结果放入相应的矩阵中
radiation[i, ] <- radiation_values
}
library(terra)
library(sirad)
library(pbapply)
# 读取NetCDF文件
filename <- system.file("extdata", "ssd.nc", package = "sola")  # 加载示例数据
ssd <- rast(filename)
# 提取所有时间属性
dates <- time(ssd)
# 提取所有像元的经纬度
lons <- xFromCell(ssd, 1:ncell(ssd))
lats <- yFromCell(ssd, 1:ncell(ssd))
# 将所有图层展开为一个长向量
ssd_values <- values(ssd)
# 初始化结果矩阵，结果与输入的维度一致
radiation <- matrix(NA, nrow = nlyr(ssd), ncol = ncell(ssd))
# 向量化计算太阳辐射
for (i in seq_len(nlyr(ssd))) {
ssd_layer_values <- ssd_values[(i - 1) * ncell(ssd) + 1:i * ncell(ssd)]  # 当前层的SSD值
valid_indices <- !is.na(ssd_layer_values) & ssd_layer_values >= 0 & ssd_layer_values <= 24  # 获取有效（非NA且在范围内）值的索引
# 计算有效的经纬度
lat_valid <- lats[valid_indices]
lon_valid <- lons[valid_indices]
ssd_valid <- ssd_layer_values[valid_indices]
# 初始化 radiation_values，确保长度与 SSD 层一致
radiation_values <- rep(NA, length(ssd_layer_values))
# 使用 sol_rad 函数计算太阳辐射
if (length(ssd_valid) > 0) {
radiation_values[valid_indices] <- sol_rad(lat = lat_valid, date = dates[i], ssd = ssd_valid, A = 0.25, B = 0.5)
}
# 将结果放入相应的矩阵中
radiation[i, ] <- radiation_values
}
library(terra)
library(sirad)
library(pbapply)
# 读取NetCDF文件
filename <- system.file("extdata", "ssd.nc", package = "sola")  # 加载示例数据
ssd <- rast(filename)
# 提取所有时间属性
dates <- time(ssd)
# 提取所有像元的经纬度
lons <- xFromCell(ssd, 1:ncell(ssd))
lats <- yFromCell(ssd, 1:ncell(ssd))
# 将所有图层展开为一个长向量
ssd_values <- values(ssd)
# 初始化结果矩阵，结果与输入的维度一致
radiation <- matrix(NA, nrow = nlyr(ssd), ncol = ncell(ssd))
# 向量化计算太阳辐射
for (i in seq_len(nlyr(ssd))) {
ssd_layer_values <- ssd_values[(i - 1) * ncell(ssd) + 1:i * ncell(ssd)]  # 当前层的SSD值
valid_indices <- !is.na(ssd_layer_values) & ssd_layer_values >= 0 & ssd_layer_values <= 24  # 获取有效（非NA且在范围内）值的索引
# 计算有效的经纬度
lat_valid <- lats[valid_indices]
lon_valid <- lons[valid_indices]
ssd_valid <- ssd_layer_values[valid_indices]
# 初始化 radiation_values，确保长度与 SSD 层一致
radiation_values <- rep(NA, length(ssd_layer_values))
# 使用 sol_rad 函数计算太阳辐射
if (length(ssd_valid) > 0) {
radiation_values[valid_indices] <- sol_rad(lat = lat_valid, date = dates[i], ssd = ssd_valid, A = 0.25, B = 0.5)
}
# 将结果放入相应的矩阵中
radiation[i, ] <- radiation_values
}
library(terra)
library(sirad)
library(pbapply)
# 读取NetCDF文件
filename <- system.file("extdata", "ssd.nc", package = "sola")  # 加载示例数据
ssd <- rast(filename)
ssd
# 假设 lat 是全球范围的固定值，可从 SSD 的空间参考中提取纬度信息
lat <- crds(ssd, df = TRUE)[, 2]  # 提取所有像元的纬度信息
163*283
lats <- yFromCell(ssd, 1:ncell(ssd))
dates <- time(ssd)
# 初始化存储计算结果的栅格
solar_radiation_raster <- rast(ssd, nlyr = nlyr(ssd))
solar_radiation_raster
# 提取所有像元的经纬度
lons <- xFromCell(ssd, 1:ncell(ssd))
lats <- yFromCell(ssd, 1:ncell(ssd))
# 提取所有时间属性
dates <- time(ssd)
# 定义计算函数，适应栅格数据
calc_solar_radiation <- function(ssd_layer, date) {
# 将每个像元的日照时长转换为太阳辐射
solar_radiation <- sol_rad(lat = lats, date = date, ssd = as.numeric(ssd_layer))
return(solar_radiation)
}
length(lats)
length(dates)
library(terra)
# 提取所有像元的经纬度
lons <- xFromCell(ssd, 1:ncell(ssd))
# 读取NetCDF文件
filename <- system.file("extdata", "ssd.nc", package = "sola")  # 加载示例数据
ssd <- rast(filename)
library(terra)
# 提取所有像元的经纬度
lons <- xFromCell(ssd, 1:ncell(ssd))
lats <- yFromCell(ssd, 1:ncell(ssd))
# 提取所有时间属性
dates <- time(ssd)
# 定义计算函数，适应栅格数据
calc_solar_radiation <- function(ssd_layer, date) {
# 将每个像元的日照时长转换为太阳辐射
solar_radiation <- sol_rad(lat = lats, date = rep(date, length(lats)), ssd = as.numeric(ssd_layer))
return(solar_radiation)
}
# 初始化存储计算结果的栅格
solar_radiation_raster <- rast(ssd, nlyr = nlyr(ssd))
# 遍历每一个时间层
for (i in 1:nlyr(ssd)) {
# 计算每一层（即每一天）的太阳辐射
solar_radiation_raster[[i]] <- calc_solar_radiation(ssd[[i]], dates[i])
}
library(terra)
# 提取所有像元的经纬度
lons <- xFromCell(ssd, 1:ncell(ssd))
lats <- yFromCell(ssd, 1:ncell(ssd))
# 提取所有时间属性
dates <- time(ssd)
# 定义计算函数，适应栅格数据
calc_solar_radiation <- function(ssd_layer, date) {
# 提取日照时长数据为数值型
ssd_values <- values(ssd_layer)
# 将每个像元的日照时长转换为太阳辐射
solar_radiation <- sol_rad(lat = lats, date = rep(date, length(lats)), ssd = ssd_values)
return(solar_radiation)
}
# 初始化存储计算结果的栅格
solar_radiation_raster <- rast(ssd, nlyr = nlyr(ssd))
# 遍历每一个时间层
for (i in 1:nlyr(ssd)) {
# 计算每一层（即每一天）的太阳辐射
solar_radiation_raster[[i]] <- setValues(ssolar_radiation_raster[[i]], calc_solar_radiation(ssd[[i]], dates[i]))
}
library(terra)
# 提取所有像元的经纬度
lons <- xFromCell(ssd, 1:ncell(ssd))
lats <- yFromCell(ssd, 1:ncell(ssd))
# 提取所有时间属性
dates <- time(ssd)
# 定义计算函数，适应栅格数据
calc_solar_radiation <- function(ssd_layer, date) {
# 提取日照时长数据为数值型
ssd_values <- values(ssd_layer)
# 将每个像元的日照时长转换为太阳辐射
solar_radiation <- sol_rad(lat = lats, date = rep(date, length(lats)), ssd = ssd_values)
return(solar_radiation)
}
# 初始化存储计算结果的栅格
solar_radiation_raster <- rast(ssd, nlyr = nlyr(ssd))
# 遍历每一个时间层
for (i in 1:nlyr(ssd)) {
# 计算每一层（即每一天）的太阳辐射
solar_radiation_raster[[i]] <- setValues(solar_radiation_raster[[i]], calc_solar_radiation(ssd[[i]], dates[i]))
}
# 查看结果
plot(solar_radiation_raster)
plot(ssd)
library(terra)
library(pbapply)  # 加载pbapply包
# 提取所有像元的经纬度
lons <- xFromCell(ssd, 1:ncell(ssd))
lats <- yFromCell(ssd, 1:ncell(ssd))
# 提取所有时间属性
dates <- time(ssd)
# 定义计算函数，适应栅格数据
calc_solar_radiation <- function(ssd_layer, date) {
# 提取日照时长数据为数值型
ssd_values <- values(ssd_layer)
# 将每个像元的日照时长转换为太阳辐射
solar_radiation <- sol_rad(lat = lats, date = rep(date, length(lats)), ssd = ssd_values)
return(solar_radiation)
}
# 初始化存储计算结果的栅格
solar_radiation_raster <- rast(ssd, nlyr = nlyr(ssd))
# 使用 pblapply 为循环添加进度条
pblapply(1:nlyr(ssd), function(i) {
# 计算每一层（即每一天）的太阳辐射
solar_radiation_raster[[i]] <- setValues(solar_radiation_raster[[i]], calc_solar_radiation(ssd[[i]], dates[i]))
})
# 查看结果
plot(solar_radiation_raster)
library(terra)
library(pbapply)  # 加载pbapply包
# 提取所有像元的经纬度
lons <- xFromCell(ssd, 1:ncell(ssd))
lats <- yFromCell(ssd, 1:ncell(ssd))
# 提取所有时间属性
dates <- time(ssd)
# 定义计算函数，适应栅格数据
calc_solar_radiation <- function(ssd_layer, date) {
# 提取日照时长数据为数值型
ssd_values <- values(ssd_layer)
# 将每个像元的日照时长转换为太阳辐射
solar_radiation <- sol_rad(lat = lats, date = rep(date, length(lats)), ssd = ssd_values)
return(solar_radiation)
}
# 初始化存储计算结果的栅格
solar_radiation_raster <- rast(ssd, nlyr = nlyr(ssd))
# 使用标准的 for 循环，配合 pbapply 的进度条
pb <- txtProgressBar(min = 0, max = nlyr(ssd), style = 3)
for (i in 1:nlyr(ssd)) {
# 计算每一层（即每一天）的太阳辐射
solar_radiation_raster[[i]] <- setValues(solar_radiation_raster[[i]], calc_solar_radiation(ssd[[i]], dates[i]))
# 更新进度条
setTxtProgressBar(pb, i)
}
# 关闭进度条
close(pb)
# 查看结果
plot(solar_radiation_raster)
?radNC
# Assuming ssd is a SpatRaster object loaded from a NetCDF file
filename <- system.file("extdata", "ssd.nc", package = "sola")
ssd <- terra:rast(filename)
Imports:
terra
library(sola)
?radNC
library(terra)
filename <- system.file("extdata", "ssd.nc", package = "sola")
ssd <- rast(filename)
result_raster <- radNC(ssd)
plot(result_raster)
# 读取NetCDF文件
ssd <- rast("D:/CN05/roi/ssd_roi.nc")
rad <- radNC(ssd)
