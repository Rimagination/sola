times = 10
)
print(benchmark_results)
# 加载必要的包
library(microbenchmark)
# 假设 SolDec 函数已经从相关包中导入
# library(FAO56)  # 如果 SolDec 在某个包中，请确保加载该包
# 定义测试日期集合
large_dates <- as.Date("2024-01-01") + 0:99  # 使用100个日期作为示例
# 将日期转换为字符格式以适应 SolDec 的输入
large_dates_char <- format(large_dates, "%Y/%m/%d")
# 使用 sol_dec 计算太阳赤纬角
sol_dec_results <- sol_dec(large_dates)
# 使用 SolDec 计算太阳赤纬角
SolDec_results <- sapply(large_dates_char, SolDec)
# 比较两个函数的结果
comparison <- data.frame(
Date = large_dates,
sol_dec = sol_dec_results,
SolDec = SolDec_results,
Difference = sol_dec_results - SolDec_results
)
# 打印比较结果
print(comparison)
# 检查结果是否一致
all_equal_results <- all.equal(sol_dec_results, SolDec_results, tolerance = 1e-6)  # 使用一个小的容差来检查浮点数的差异
print(all_equal_results)
# 加载必要的包
library(microbenchmark)
# 假设 SolDec 函数已经从相关包中导入
# library(FAO56)  # 如果 SolDec 在某个包中，请确保加载该包
# 定义测试日期集合
large_dates <- as.Date("2024-01-01") + 0:99  # 使用100个日期作为示例
# 将日期转换为字符格式以适应 SolDec 的输入
large_dates_char <- format(large_dates, "%Y/%m/%d")
# 使用 sol_dec 计算太阳赤纬角，设置输出为弧度
sol_dec_results_rad <- sol_dec(large_dates, in_radians = TRUE)
# 使用 SolDec 计算太阳赤纬角（输出为弧度）
SolDec_results <- sapply(large_dates_char, SolDec)
# 比较两个函数的结果
comparison <- data.frame(
Date = large_dates,
sol_dec = sol_dec_results_rad,
SolDec = SolDec_results,
Difference = sol_dec_results_rad - SolDec_results
)
# 打印比较结果
print(comparison)
# 检查结果是否一致
all_equal_results <- all.equal(sol_dec_results_rad, SolDec_results, tolerance = 1e-6)  # 使用一个小的容差来检查浮点数的差异
print(all_equal_results)
# 加载必要的包
library(future.apply)
# 优化的 ext_rad 函数，支持并行计算
ext_rad <- function(lat, date) {
if (!is.numeric(lat)) stop("Latitude must be numeric.")
lat_rad <- lat * pi / 180  # Convert latitude to radians
date <- tryCatch(as.Date(date), error = function(e) stop("Invalid date input."))
# Calculate day of year
J <- doy(date)
# Calculate solar declination
delta_angle <- sol_dec(date, in_radians = TRUE) # Return in radians
# Calculate sunset hour angle
omega_s <- 2 * acos(-tan(lat_rad) * tan(delta_angle))
# Calculate inverse relative distance Earth-Sun
dr <- 1 + 0.033 * cos(2 * pi * J / 365)
# Calculate extraterrestrial radiation
Gsc <- 0.0820  # Solar constant (MJ/m²/min)
Ra <- (24 * 60 / pi) * Gsc * dr * (cos(lat_rad) * cos(delta_angle) * sin(omega_s) +
sin(lat_rad) * sin(delta_angle) * cos(omega_s))  # MJ/m²/day
return(Ra)
}
# 测试数据集
latitudes <- seq(-90, 90, by = 1)  # 181 latitudes
dates <- as.Date("2024-01-01") + 0:364  # 365 dates in a year
# 并行计算：使用 future.apply 进行并行化
future::plan("multisession", workers = parallel::detectCores() - 1)  # 设置并行策略
# 并行计算时间
system.time({
results_parallel <- future_mapply(ext_rad,
lat = rep(latitudes, each = length(dates)),
date = rep(dates, times = length(latitudes)))
})
# 单线程计算时间
system.time({
results_single <- mapply(ext_rad,
lat = rep(latitudes, each = length(dates)),
date = rep(dates, times = length(latitudes)))
})
warnings()
?ext_rad
test_date <- as.Date("2023-01-01") + sample(0:364, 10000, replace = TRUE)  # Generate 10,000 random dates in 2023
result_ext_rad <- mapply(ext_rad, lat = test_lat, date = test_date)  # Apply ext_rad to the long vector inputs
print(head(result_ext_rad))  # Print the first few results
warnings()
# Handling a large dataset of latitudes and dates
set.seed(123)
test_lat <- runif(10000, -90, 90)  # Generate 10,000 random latitudes
test_date <- as.Date("2023-01-01") + sample(0:364, 10000, replace = TRUE)  # Generate 10,000 random dates in 2023
result_ext_rad <- mapply(ext_rad, lat = test_lat, date = test_date)  # Apply ext_rad to the long vector inputs
print(head(result_ext_rad))  # Print the first few results
warnings()
ext_rad(lat = 35.0, date = as.Date("2023-03-15"))
ext_rad(lat = -15.0, date = "2024-06-21")
# Example with a large dataset
set.seed(123)
test_lat <- runif(10000, -90, 90)  # Generate random latitudes
test_date <- as.Date("2023-01-01") + sample(0:364, 10000, replace = TRUE)  # Generate random dates in 2023
result_ext_rad <- ext_rad(test_lat, test_date)
print(head(result_ext_rad))
# 定义 ExRad 函数
ExRad <- function(d_r, omega_s, phi, delta, G_sc = 0.082) {
Ra <- (24 * 60 / pi) * G_sc * d_r * (cos(phi) * cos(delta) * sin(omega_s) +
omega_s * sin(phi) * sin(delta))
return(Ra)
}
# 使用 ext_rad 函数计算纬度 90 度（北极点）的辐射
library(lubridate)
# 设置测试日期（夏至 6 月 21 日）
test_date <- as.Date("2023-06-21")
# 计算太阳赤纬角 delta
J <- yday(test_date)  # Calculate the day of year
delta <- 23.45 * sin(pi / 180 * (360 / 365) * (J - 81)) * pi / 180  # Convert to radians
# 逆地球-太阳距离 d_r
d_r <- 1 + 0.033 * cos(2 * pi * J / 365)
# 日落时角 omega_s
omega_s <- pi  # 极昼情况下，假设全天日照
# 纬度 phi
phi <- 90 * pi / 180  # Convert to radians
# 使用 ExRad 计算
exrad_result <- ExRad(d_r, omega_s, phi, delta)
# 使用 ext_rad 计算
ext_rad_result <- ext_rad(lat = 90, date = test_date)
# 打印结果
cat("ExRad result:", exrad_result, "\n")
cat("ext_rad result:", ext_rad_result, "\n")
# Example with a large dataset
set.seed(123)
test_lat <- runif(10000, -89, 89)  # Generate random latitudes within recommended range
test_date <- as.Date("2023-01-01") + sample(0:364, 10000, replace = TRUE)  # Generate random dates in 2023
result_ext_rad <- ext_rad(test_lat, test_date)
print(head(result_ext_rad))
head(test_lat)
head(test_date)
ext_rad <- function(lat, date) {
if (!is.numeric(lat)) stop("Latitude must be numeric.")
if (any(lat < -90 | lat > 90)) stop("Latitude must be between -90 and 90 degrees.")
lat_rad <- lat * pi / 180  # Convert latitude to radians
date <- tryCatch(as.Date(date), error = function(e) stop("Invalid date input."))
# Calculate day of year
J <- as.numeric(format(date, "%j"))
# Calculate solar declination using FAO56 formula
delta_angle <- 23.45 * sin(pi / 180 * (360 / 365) * (J - 81))
delta_rad <- delta_angle * pi / 180  # Convert to radians
# Calculate sunset hour angle using SunHA method
x <- -tan(lat_rad) * tan(delta_rad)
x <- pmin(pmax(x, -1), 1)  # Clip values to ensure within [-1, 1] range
omega_s <- acos(x)
# Calculate inverse relative distance Earth-Sun
dr <- 1 + 0.033 * cos(2 * pi * J / 365)
# Calculate extraterrestrial radiation
Gsc <- 0.0820  # Solar constant (MJ/m²/min)
Ra <- (24 * 60 / pi) * Gsc * dr * (cos(lat_rad) * cos(delta_rad) * sin(omega_s) +
sin(lat_rad) * sin(delta_rad) * omega_s)  # MJ/m²/day
return(Ra)
}
# Example with a large dataset
set.seed(123)
test_lat <- runif(10000, -89, 89)  # Generate random latitudes within recommended range
test_date <- as.Date("2023-01-01") + sample(0:364, 10000, replace = TRUE)  # Generate random dates in 2023
result_ext_rad <- ext_rad(test_lat, test_date)
print(head(result_ext_rad))
# 加载必要的包
library(lubridate)
# 定义 FAO56 的日落时角计算函数 SunHA
SunHA <- function(phi, delta) {
x <- -tan(phi) * tan(delta)
x <- pmin(pmax(x, -1), 1)  # 强制限制 x 的范围在 [-1, 1]
omega_s <- acos(x)
return(omega_s)
}
# 定义 FAO56 的地外太阳辐射计算函数 ExRad
ExRad <- function(d_r, omega_s, phi, delta, G_sc = 0.082) {
Ra <- (24 * 60 / pi) * G_sc * d_r * (cos(phi) * cos(delta) * sin(omega_s) +
omega_s * sin(phi) * sin(delta))
return(Ra)
}
# 使用 ext_rad 函数
ext_rad <- function(lat, date) {
if (!is.numeric(lat)) stop("Latitude must be numeric.")
if (any(lat < -90 | lat > 90)) stop("Latitude must be between -90 and 90 degrees.")
lat_rad <- lat * pi / 180  # Convert latitude to radians
date <- tryCatch(as.Date(date), error = function(e) stop("Invalid date input."))
# Calculate day of year
J <- as.numeric(format(date, "%j"))
# Calculate solar declination using FAO56 formula
delta_angle <- 23.45 * sin(pi / 180 * (360 / 365) * (J - 81))
delta_rad <- delta_angle * pi / 180  # Convert to radians
# Calculate sunset hour angle using SunHA method
x <- -tan(lat_rad) * tan(delta_rad)
x <- pmin(pmax(x, -1), 1)  # Clip values to ensure within [-1, 1] range
omega_s <- acos(x)
# Calculate inverse relative distance Earth-Sun
dr <- 1 + 0.033 * cos(2 * pi * J / 365)
# Calculate extraterrestrial radiation
Gsc <- 0.0820  # Solar constant (MJ/m²/min)
Ra <- (24 * 60 / pi) * Gsc * dr * (cos(lat_rad) * cos(delta_rad) * sin(omega_s) +
sin(lat_rad) * sin(delta_rad) * omega_s)  # MJ/m²/day
return(Ra)
}
# 设置测试数据，包括极端纬度
test_lat <- c(0, 45, 60, 75, 89, 90, -45, -60, -75, -89, -90)
test_date <- as.Date("2023-06-21")  # 夏至日
# 对比两个函数的结果
results <- data.frame(
Latitude = test_lat,
Date = test_date,
ext_rad_Result = sapply(test_lat, function(lat) ext_rad(lat, test_date)),
ExRad_Result = sapply(test_lat, function(lat) {
phi <- lat * pi / 180
J <- yday(test_date)
delta <- 23.45 * sin(pi / 180 * (360 / 365) * (J - 81)) * pi / 180
d_r <- 1 + 0.033 * cos(2 * pi * J / 365)
omega_s <- SunHA(phi, delta)
ExRad(d_r, omega_s, phi, delta)
})
)
# 打印结果对比
print(results)
# 示例用法
print(day_length(lat = 35, date = as.Date("2023-03-15")))  # 单个输入
print(day_length(lat = c(-15, 45), date = c("2024-06-21", "2023-12-21")))  # 多个输入
# 测试大数据集
set.seed(123)
test_lat <- runif(10000, -90, 90)  # 生成 10,000 个随机纬度
test_date <- as.Date("2023-01-01") + sample(0:364, 10000, replace = TRUE)  # 生成 10,000 个随机日期
result_day_length <- day_length(test_lat, test_date)
print(head(result_day_length))  # 查看前几个结果
# 测试当前的 sol_dec 函数性能
system.time({
large_dates <- as.Date("2024-01-01") + 0:999999  # 生成一百万个日期
result_large <- sol_dec(large_dates)
})
# 加载必要的包
# 如果没有这些包，请先安装
# install.packages("lubridate")
# 使用优化后的 sol_rad 函数
sol_rad <- function(lat, date, ssd, N = NULL, ext_rad = NULL, A = 0.25, B = 0.50) {
# Ensure inputs are vectors of the same length
len <- max(length(lat), length(date), length(ssd))
lat <- rep(lat, length.out = len)
date <- rep(date, length.out = len)
ssd <- rep(ssd, length.out = len)
# Validate inputs
if (any(!is.numeric(lat))) stop("Latitude must be numeric.")
if (any(lat < -90 | lat > 90)) stop("Latitude must be between -90 and 90 degrees.")
if (any(!is.numeric(ssd) | ssd < 0 | ssd > 24)) stop("Sunshine duration must be a number between 0 and 24.")
# Convert date if necessary
date <- tryCatch(as.Date(date), error = function(e) stop("Invalid date input."))
# Calculate extraterrestrial radiation if not provided
if (is.null(ext_rad)) {
ext_rad <- ext_rad(lat, date)  # Assuming ext_rad function is vectorized
}
# Calculate day length (N) if not provided
if (is.null(N)) {
N <- day_length(lat, date)  # Assuming day_length function is vectorized
}
# Function to calculate radiation using Angstrom-Prescott equation
calc_rad <- function(A, B, ssd, N, ext_rad) {
(A + B * (ssd / N)) * ext_rad
}
# Standard sequential calculation using vectorized operations
rad_estimate <- calc_rad(A, B, ssd, N, ext_rad)
# Return results
return(rad_estimate)
}
# 设置测试参数
set.seed(123)
# 测试 1: 小规模数据
test_lat_small <- c(35, -15)
test_date_small <- c(as.Date("2023-03-15"), as.Date("2024-06-21"))
test_ssd_small <- c(8, 10)
# 运行函数并打印结果
print(sol_rad(lat = test_lat_small, date = test_date_small, ssd = test_ssd_small))
# 测试 2: 大规模数据
test_lat_large <- runif(10000, -90, 90)  # 生成 10,000 个随机纬度
test_date_large <- as.Date("2023-01-01") + sample(0:364, 10000, replace = TRUE)  # 生成 10,000 个随机日期
test_ssd_large <- runif(10000, 0, 24)  # 生成 10,000 个随机日照时间
# 测试大数据集性能
system.time({
result_large <- sol_rad(lat = test_lat_large, date = test_date_large, ssd = test_ssd_large)
})
# 打印前几个结果
print(head(result_large))
# Debugging version of sol_rad function
sol_rad <- function(lat, date, ssd, N = NULL, ext_rad = NULL, A = 0.25, B = 0.50) {
# Ensure inputs are vectors of the same length
len <- max(length(lat), length(date), length(ssd))
lat <- rep(lat, length.out = len)
date <- rep(date, length.out = len)
ssd <- rep(ssd, length.out = len)
# Validate inputs
if (any(!is.numeric(lat))) stop("Latitude must be numeric.")
if (any(lat < -90 | lat > 90)) stop("Latitude must be between -90 and 90 degrees.")
if (any(!is.numeric(ssd) | ssd < 0 | ssd > 24)) stop("Sunshine duration must be a number between 0 and 24.")
# Convert date if necessary
date <- tryCatch(as.Date(date), error = function(e) stop("Invalid date input."))
# Calculate extraterrestrial radiation if not provided
if (is.null(ext_rad)) {
ext_rad <- ext_rad(lat, date)  # Assuming ext_rad function is vectorized
}
# Calculate day length (N) if not provided
if (is.null(N)) {
N <- day_length(lat, date)  # Assuming day_length function is vectorized
}
# Check for NaNs in N or ext_rad
if (any(is.na(N))) warning("Detected NaN in day length (N)")
if (any(is.na(ext_rad))) warning("Detected NaN in extraterrestrial radiation (ext_rad)")
# Function to calculate radiation using Angstrom-Prescott equation
calc_rad <- function(A, B, ssd, N, ext_rad) {
result <- (A + B * (ssd / N)) * ext_rad
if (is.nan(result)) {
warning(sprintf("NaN detected in radiation calculation: A = %f, B = %f, ssd = %f, N = %f, ext_rad = %f",
A, B, ssd, N, ext_rad))
}
return(result)
}
# Standard sequential calculation using vectorized operations
rad_estimate <- calc_rad(A, B, ssd, N, ext_rad)
# Return results
return(rad_estimate)
}
# 加载必要的包
# 如果没有这些包，请先安装
# install.packages("lubridate")
# 使用优化后的 sol_rad 函数
sol_rad <- function(lat, date, ssd, N = NULL, ext_rad = NULL, A = 0.25, B = 0.50) {
# Ensure inputs are vectors of the same length
len <- max(length(lat), length(date), length(ssd))
lat <- rep(lat, length.out = len)
date <- rep(date, length.out = len)
ssd <- rep(ssd, length.out = len)
# Validate inputs
if (any(!is.numeric(lat))) stop("Latitude must be numeric.")
if (any(lat < -90 | lat > 90)) stop("Latitude must be between -90 and 90 degrees.")
if (any(!is.numeric(ssd) | ssd < 0 | ssd > 24)) stop("Sunshine duration must be a number between 0 and 24.")
# Convert date if necessary
date <- tryCatch(as.Date(date), error = function(e) stop("Invalid date input."))
# Calculate extraterrestrial radiation if not provided
if (is.null(ext_rad)) {
ext_rad <- ext_rad(lat, date)  # Assuming ext_rad function is vectorized
}
# Calculate day length (N) if not provided
if (is.null(N)) {
N <- day_length(lat, date)  # Assuming day_length function is vectorized
}
# Function to calculate radiation using Angstrom-Prescott equation
calc_rad <- function(A, B, ssd, N, ext_rad) {
(A + B * (ssd / N)) * ext_rad
}
# Standard sequential calculation using vectorized operations
rad_estimate <- calc_rad(A, B, ssd, N, ext_rad)
# Return results
return(rad_estimate)
}
# 设置测试参数
set.seed(123)
# 测试 1: 小规模数据
test_lat_small <- c(35, -15)
test_date_small <- c(as.Date("2023-03-15"), as.Date("2024-06-21"))
test_ssd_small <- c(8, 10)
# 运行函数并打印结果
print(sol_rad(lat = test_lat_small, date = test_date_small, ssd = test_ssd_small))
# 测试 2: 大规模数据
test_lat_large <- runif(10000, -90, 90)  # 生成 10,000 个随机纬度
test_date_large <- as.Date("2023-01-01") + sample(0:364, 10000, replace = TRUE)  # 生成 10,000 个随机日期
test_ssd_large <- runif(10000, 0, 24)  # 生成 10,000 个随机日照时间
# 测试大数据集性能
system.time({
result_large <- sol_rad(lat = test_lat_large, date = test_date_large, ssd = test_ssd_large)
})
# 打印前几个结果
print(head(result_large))
head(test_lat_large)
head(test_date_large)
head(ssd = test_ssd_large)
head(test_ssd_large)
sol_rad(lat = -38.23605, date = "2023-10-03", ssd = 22.034976)
sol_rad(lat = 79.28411, date = "2023-11-02", ssd = 14.957764)
# Enhanced sol_rad function with debug and validation
sol_rad <- function(lat, date, ssd, N = NULL, ext_rad = NULL, A = 0.25, B = 0.50) {
# Ensure inputs are vectors of the same length
len <- max(length(lat), length(date), length(ssd))
lat <- rep(lat, length.out = len)
date <- rep(date, length.out = len)
ssd <- rep(ssd, length.out = len)
# Validate inputs
if (any(!is.numeric(lat))) stop("Latitude must be numeric.")
if (any(lat < -90 | lat > 90)) stop("Latitude must be between -90 and 90 degrees.")
if (any(!is.numeric(ssd) | ssd < 0 | ssd > 24)) stop("Sunshine duration must be a number between 0 and 24.")
# Convert date if necessary
date <- tryCatch(as.Date(date), error = function(e) stop("Invalid date input."))
# Calculate extraterrestrial radiation if not provided
if (is.null(ext_rad)) {
ext_rad <- ext_rad(lat, date)  # Assuming ext_rad function is vectorized
}
# Calculate day length (N) if not provided
if (is.null(N)) {
N <- day_length(lat, date)  # Assuming day_length function is vectorized
}
# Check for NaNs and invalid values in N and ext_rad
if (any(is.na(N))) warning("Detected NaN in day length (N). Adjusting values.")
if (any(is.na(ext_rad))) warning("Detected NaN in extraterrestrial radiation (ext_rad). Adjusting values.")
# Replace invalid values with small positive numbers to prevent division errors
N[N <= 0 | is.na(N)] <- 1e-6  # Set a very small number if N is zero or NaN
ssd <- pmin(ssd, N)  # Ensure ssd does not exceed N
# Function to calculate radiation using Angstrom-Prescott equation
calc_rad <- function(A, B, ssd, N, ext_rad) {
result <- (A + B * (ssd / N)) * ext_rad
if (is.nan(result)) {
warning(sprintf("NaN detected in radiation calculation: A = %f, B = %f, ssd = %f, N = %f, ext_rad = %f",
A, B, ssd, N, ext_rad))
}
return(result)
}
# Standard sequential calculation using vectorized operations
rad_estimate <- calc_rad(A, B, ssd, N, ext_rad)
# Return results
return(rad_estimate)
}
# 运行测试案例
result <- sol_rad(lat = 79.28411, date = "2023-11-02", ssd = 14.957764)
print(result)
# 创建一个大数据集进行性能测试
set.seed(123)
large_test_lat <- runif(100000, -90, 90)  # 生成 100,000 个随机纬度
large_test_date <- as.Date("2023-01-01") + sample(0:364, 100000, replace = TRUE)  # 生成 100,000 个随机日期
large_test_ssd <- runif(100000, 0, 24)  # 生成 100,000 个随机日照时间
# 测试大数据集的处理时间
system.time({
large_result <- sol_rad(lat = large_test_lat, date = large_test_date, ssd = large_test_ssd)
})
# 创建一个大数据集进行性能测试
set.seed(123)
large_test_lat <- runif(100000, -90, 90)  # 生成 100,000 个随机纬度
large_test_date <- as.Date("2023-01-01") + sample(0:364, 100000, replace = TRUE)  # 生成 100,000 个随机日期
large_test_ssd <- runif(100000, 0, 24)  # 生成 100,000 个随机日照时间
# 测试大数据集的处理时间
system.time({
large_result <- sol_rad(lat = large_test_lat, date = large_test_date, ssd = large_test_ssd)
})
# 创建一个大数据集进行性能测试
set.seed(123)
large_test_lat <- runif(100000, -90, 90)  # 生成 100,000 个随机纬度
large_test_date <- as.Date("2023-01-01") + sample(0:364, 100000, replace = TRUE)  # 生成 100,000 个随机日期
large_test_ssd <- runif(100000, 0, 24)  # 生成 100,000 个随机日照时间
# 测试大数据集的处理时间
system.time({
large_result <- sol_rad(lat = large_test_lat, date = large_test_date, ssd = large_test_ssd)
})
# 创建一个大数据集进行性能测试
set.seed(123)
large_test_lat <- runif(100000, -90, 90)  # 生成 100,000 个随机纬度
large_test_date <- as.Date("2023-01-01") + sample(0:364, 100000, replace = TRUE)  # 生成 100,000 个随机日期
large_test_ssd <- runif(100000, 0, 24)  # 生成 100,000 个随机日照时间
# 测试大数据集的处理时间
system.time({
large_result <- sol_rad(lat = large_test_lat, date = large_test_date, ssd = large_test_ssd)
})
# 创建一个大数据集进行性能测试
set.seed(123)
large_test_lat <- runif(100000, -90, 90)  # 生成 100,000 个随机纬度
large_test_date <- as.Date("2023-01-01") + sample(0:364, 100000, replace = TRUE)  # 生成 100,000 个随机日期
large_test_ssd <- runif(100000, 0, 24)  # 生成 100,000 个随机日照时间
# 测试大数据集的处理时间
system.time({
large_result <- sol_rad(lat = large_test_lat, date = large_test_date, ssd = large_test_ssd)
})
# 创建一个大数据集进行性能测试
set.seed(123)
large_test_lat <- runif(100000, -90, 90)  # 生成 100,000 个随机纬度
large_test_date <- as.Date("2023-01-01") + sample(0:364, 100000, replace = TRUE)  # 生成 100,000 个随机日期
large_test_ssd <- runif(100000, 0, 24)  # 生成 100,000 个随机日照时间
# 测试大数据集的处理时间
system.time({
large_result <- sol_rad(lat = large_test_lat, date = large_test_date, ssd = large_test_ssd)
})
# 创建一个大数据集进行性能测试
set.seed(123)
large_test_lat <- runif(100000, -90, 90)  # 生成 100,000 个随机纬度
large_test_date <- as.Date("2023-01-01") + sample(0:364, 100000, replace = TRUE)  # 生成 100,000 个随机日期
large_test_ssd <- runif(100000, 0, 24)  # 生成 100,000 个随机日照时间
# 测试大数据集的处理时间
system.time({
large_result <- sol_rad(lat = large_test_lat, date = large_test_date, ssd = large_test_ssd)
})
?sol_rad
install.packages("lintr")
lintr::lint_package()
# 安装 {styler}# install.packages("styler")
# 对整个包进行代码美化
styler::style_pkg()
?day_length()
day_length(lat = 35, date = as.Date("2023-03-15"))
day_length(lat = c(-15, 45), date = c("2024-06-21", "2023-12-21"))
# 默认的 README.Rmd 模版就创建完
usethis::use_readme_rmd()
# 默认的 README.Rmd 模版就创建完
usethis::use_readme_rmd()
# 默认的 README.Rmd 模版就创建完
usethis::use_readme_rmd()
pak::pak("renliang1996/sola")
